From 46cdbfe0a3722713eb907439f8731f578733d8da Mon Sep 17 00:00:00 2001
From: Daniel Mendler <mail@daniel-mendler.de>
Date: Fri, 6 Feb 2026 15:19:42 +0100
Subject: [PATCH] New image type canvas

See bug#80281.

Canvas changes:

* etc/emacs_lldb.py: Add `PVEC_CANVAS' type.
* src/alloc.c (cleanup_vector):
* src/pdumper.c (dump_vectorlike):
* src/print.c (print_vectorlike_unreadable):
* src/data.c (cl-type-of): Handle `PVEC_CANVAS'.
* src/dispextern.h (HAVE_CANVAS): New define.
(struct image): Add `image.refresh' field to the struct.
(canvas_prepare, canvas_refresh, canvas_pixel, redraw_canvas_glyphs):
New prototypes.
* src/image.c (canvas_refresh, canvas_pixel, canvas_prepare, canvas_get)
(canvas_load, canvas_image_p): New functions.
(canvas_map): Weak hash map associating canvas ids with canvas objects.
(prepare_image_for_display): Call `canvas_refresh_image'.
(syms_of_image): Create `canvas_map' hash table and register canvas
symbols and image type.
(image_set_transform): Use CAIRO_FILTER_GOOD for improved performance
when scaling images. See the message at
https://lists.gnu.org/r/emacs-devel/2025-07/msg00475.html.
* src/xdisp.c (redraw_canvas_glyphs): New function to redraw single
glyphs.
* src/lisp.h (PVEC_CANVAS, Lisp_Canvas, CANVASP, XCANVAS): New
pseudovector type.
* src/emacs-module.c (module_canvas_pixel, module_canvas_refresh): New
module function.
(initialize_environment): Register new module functions.
* src/module-env-31.h (canvas_pixel, canvas_refresh): New prototypes.
* doc/lispref/display.texi (Canvas Images): Document canvas images.
* doc/lispref/elisp.texi: Reference node canvas images.
* test/src/emacs-module-resources/mod-test.c (mod-test-canvas): New
helper function.
* test/src/emacs-module-tests.el (mod-test-canvas/valid)
(mod-test-canvas/invalid): New tests.
* etc/NEWS: Announce the addition.

Additional changes:

* src/window.c (REDISPLAY_BUFFER_WINDOWS_NO_MODE_LINE)
(REDISPLAY_BUFFER_WINDOWS_MODE_LINE): New window loop operations to
avoid mode line update.
(window_loop): Handle the operations.
(force-window-update): Add optional argument NO-MODE-LINE.
(mark_window_display_accurate_1): Ensure that `redisplay_other_windows'
is called if the window is marked inaccurate.
* doc/lispref/display.texi (force-mode-line-update): Document additional
argument NO-MODE-LINE.
---
 doc/lispref/display.texi                   |  65 +++++-
 doc/lispref/elisp.texi                     |   1 +
 etc/NEWS                                   |   7 +
 etc/emacs_lldb.py                          |   1 +
 src/alloc.c                                |   4 +
 src/data.c                                 |   2 +
 src/dispextern.h                           |  14 ++
 src/emacs-module.c                         |  24 +++
 src/image.c                                | 233 ++++++++++++++++++++-
 src/lisp.h                                 |  27 +++
 src/module-env-31.h                        |  11 +
 src/pdumper.c                              |   1 +
 src/print.c                                |   9 +
 src/window.c                               |  41 ++--
 src/xdisp.c                                |  56 ++++-
 test/src/emacs-module-resources/mod-test.c |  23 ++
 test/src/emacs-module-tests.el             |  24 +++
 17 files changed, 526 insertions(+), 17 deletions(-)

diff --git a/doc/lispref/display.texi b/doc/lispref/display.texi
index 464c0badc36..3f5e8205f13 100644
--- a/doc/lispref/display.texi
+++ b/doc/lispref/display.texi
@@ -105,13 +105,16 @@ Forcing Redisplay
 pending redisplay work (as if their contents had completely changed),
 but does not immediately try to perform redisplay.
 
-@defun force-window-update &optional object
+@defun force-window-update &optional object no-mode-line
 This function forces some or all windows to be updated the next time
 Emacs does a redisplay.  If @var{object} is a window, that window is
 to be updated.  If @var{object} is a buffer or buffer name, all
 windows displaying that buffer are to be updated.  If @var{object} is
 @code{nil} (or omitted), all windows are to be updated.
 
+Mode lines are excluded from the update if @var{no-mode-line} is
+non-@code{nil}.
+
 This function does not do a redisplay immediately; Emacs does that as
 it waits for input, or when the function @code{redisplay} is called.
 @end defun
@@ -5960,6 +5963,7 @@ Images
 * Defining Images::     Convenient ways to define an image for later use.
 * Showing Images::      Convenient ways to display an image once it is defined.
 * Multi-Frame Images::  Some images contain more than one frame.
+* Canvas Images::       Images backed by a writable ARGB32 memory buffer.
 * Image Cache::         Internal mechanisms of image display.
 @end menu
 
@@ -7411,6 +7415,65 @@ Multi-Frame Images
 if there is one.
 @end defun
 
+@node Canvas Images
+@subsection Canvas Images
+@cindex canvas image
+
+Canvas images have an associated writeable ARGB32 pixel buffer.  They
+can be used by dynamic modules to efficiently display and update images,
+for example by document viewers, visualization tools, dynamically
+computed animations or games.  An image specifier with @code{:type
+canvas} creates a canvas, for instance as follows:
+
+@lisp
+(defvar my-canvas
+  '(image :type canvas
+          :canvas-id my-identifier
+          :canvas-width 800
+          :canvas-height 600))
+@end lisp
+
+The image specification must specify a unique identifier symbol
+@code{:canvas-id}.  The identifier must be different for two canvases
+with different size.  The positive integer width and positive integer
+height of the canvas @code{:canvas-width} and @code{:canvas-height} are
+mandatory.
+
+Other image properties like @code{:scale}, @code{:margin},
+@code{:relief}, @code{:scale}, @code{:transform-smoothing} and
+@code{:map} are supported.
+
+In order to display the canvas, specify it as display property of a
+string or overlay:
+
+@lisp
+(insert (propertize "#" 'display my-canvas))
+(overlay-put some-overlay 'display my-canvas)
+@end lisp
+
+The module function @code{canvas_pixel} gives access to the writable
+pixel buffer in ARGB32 format.  The buffer has size @var{width} *
+@var{height} and is organized in row-major order.  After drawing to the
+pixel buffer, redraw the canvas with a call to @code{canvas_refresh}.
+See @xref{Writing Dynamic Modules} for details regarding dynamic
+modules.
+
+@deftypefn Function uint32_t *canvas_pixel (emacs_env *@var{env}, emacs_value @var{canvas})
+The function gives access to the pixel buffer.  The pixel buffer is in
+row-major order with a size @var{width} * @var{height}.  The returned
+pointer will be valid as long as the object @var{canvas} is alive.
+@end deftypefn
+
+@deftypefn Function void canvas_refresh (emacs_env *@var{env}, emacs_value @var{canvas})
+Request that the @var{canvas} image is redrawn.
+@end deftypefn
+
+@example
+uint32_t *pixel = env->canvas_pixel (env, canvas);
+// Write to the pixel buffer...
+env->canvas_refresh (env, canvas);
+@end example
+
 
 @node Image Cache
 @subsection Image Cache
diff --git a/doc/lispref/elisp.texi b/doc/lispref/elisp.texi
index 020095884d3..350d7da831e 100644
--- a/doc/lispref/elisp.texi
+++ b/doc/lispref/elisp.texi
@@ -1567,6 +1567,7 @@ Top
 * Showing Images::          Convenient ways to display an image once
                               it is defined.
 * Multi-Frame Images::      Some images contain more than one frame.
+* Canvas Images::           Images backed by a writable ARGB32 memory buffer.
 * Image Cache::             Internal mechanisms of image display.
 
 Buttons
diff --git a/etc/NEWS b/etc/NEWS
index ea3191680a1..fe07024ddd6 100644
--- a/etc/NEWS
+++ b/etc/NEWS
@@ -82,6 +82,13 @@ other directory on your system.  You can also invoke the
 
 * Changes in Emacs 31.1
 
++++
+** Support for canvas image objects.
+An image specifier with ':type canvas' creates a canvas image.  The
+canvas has an associated writable pixel buffer in ARGB32 format.  The
+dynamic module function 'canvas_pixel' gives access to the pixel buffer.
+After drawing to the pixel buffer, call 'canvas_refresh' to redraw.
+
 +++
 ** 'line-spacing' now supports specifying spacing above the line.
 Previously, only spacing below the line could be specified.  The user
diff --git a/etc/emacs_lldb.py b/etc/emacs_lldb.py
index 2d2dd00c02a..54e58f4c0c6 100644
--- a/etc/emacs_lldb.py
+++ b/etc/emacs_lldb.py
@@ -78,6 +78,7 @@ class Lisp_Object:
         "PVEC_TS_NODE": "struct Lisp_TS_Node",
         "PVEC_TS_PARSER": "struct Lisp_TS_Parser",
         "PVEC_TS_COMPILED_QUERY": "struct Lisp_TS_Query",
+        "PVEC_CANVAS": "struct Lisp_Canvas",
     }
 
     # Object construction/initialization.
diff --git a/src/alloc.c b/src/alloc.c
index c0c24c65737..94047a30543 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -163,6 +163,7 @@ Copyright (C) 1985-2026 Free Software Foundation, Inc.
   struct Lisp_Overlay Lisp_Overlay;
   struct Lisp_Subr Lisp_Subr;
   struct Lisp_Sqlite Lisp_Sqlite;
+  struct Lisp_Canvas Lisp_Canvas;
   struct Lisp_User_Ptr Lisp_User_Ptr;
   struct terminal terminal;
   struct thread_state thread_state;
@@ -3209,6 +3210,9 @@ cleanup_vector (struct Lisp_Vector *vector)
 	hash_table_allocated_bytes -= bytes;
       }
       break;
+    case PVEC_CANVAS:
+      xfree (PSEUDOVEC_STRUCT (vector, Lisp_Canvas)->pixel);
+      break;
     /* Keep the switch exhaustive.  */
     case PVEC_NORMAL_VECTOR:
     case PVEC_FREE:
diff --git a/src/data.c b/src/data.c
index da8ca42e565..96c34eeec9e 100644
--- a/src/data.c
+++ b/src/data.c
@@ -291,6 +291,8 @@ DEFUN ("cl-type-of", Fcl_type_of, Scl_type_of, 1, 1, 0,
 	  return Qtreesit_compiled_query;
         case PVEC_SQLITE:
           return Qsqlite;
+        case PVEC_CANVAS:
+          return Qcanvas;
         case PVEC_SUB_CHAR_TABLE:
           return Qsub_char_table;
         /* "Impossible" cases.  */
diff --git a/src/dispextern.h b/src/dispextern.h
index 30785b9ccdf..7dab7fb6a42 100644
--- a/src/dispextern.h
+++ b/src/dispextern.h
@@ -24,6 +24,10 @@ #define DISPEXTERN_H_INCLUDED
 
 #include "character.h"
 
+#if defined HAVE_MODULES && (defined HAVE_X_WINDOWS || defined USE_CAIRO)
+#  define HAVE_CANVAS 1
+#endif
+
 #ifdef HAVE_X_WINDOWS
 
 #include <X11/Xlib.h>
@@ -3318,6 +3322,9 @@ #define CENTERED_IMAGE_ASCENT -1
   /* Image id of this image.  */
   ptrdiff_t id;
 
+  /* Refresh counter reflecting the current version of the image.  */
+  int refresh;
+
   /* Hash collision chain.  */
   struct image *next, *prev;
 };
@@ -3590,6 +3597,7 @@ #define DEFAULT_TOOL_BAR_IMAGE_HEIGHT 24
 
 #ifdef HAVE_WINDOW_SYSTEM
 
+extern void redraw_canvas_glyphs (Lisp_Object);
 extern void gui_get_glyph_overhangs (struct glyph *, struct frame *,
                                      int *, int *);
 extern struct font *font_for_underline_metrics (struct glyph_string *);
@@ -3679,6 +3687,12 @@ #define TRY_WINDOW_IGNORE_FONTS_CHANGE	(1 << 1)
 
 /* Defined in image.c */
 
+#ifdef HAVE_CANVAS
+extern uint32_t* canvas_pixel (Lisp_Object);
+extern void canvas_refresh (Lisp_Object);
+extern void canvas_prepare (struct frame *f, struct image *img);
+#endif
+
 #ifdef HAVE_WINDOW_SYSTEM
 
 extern void clear_image_cache (struct frame *, Lisp_Object);
diff --git a/src/emacs-module.c b/src/emacs-module.c
index 2696a6c0376..450ed8886ff 100644
--- a/src/emacs-module.c
+++ b/src/emacs-module.c
@@ -964,6 +964,28 @@ module_vec_size (emacs_env *env, emacs_value vector)
   return ASIZE (lisp);
 }
 
+static uint32_t*
+module_canvas_pixel (emacs_env *env, emacs_value canvas)
+{
+  uint32_t* pixel = NULL;
+  MODULE_FUNCTION_BEGIN (NULL);
+#ifdef HAVE_CANVAS
+  pixel = canvas_pixel (value_to_lisp (canvas));
+#endif
+  MODULE_INTERNAL_CLEANUP ();
+  return pixel;
+}
+
+static void
+module_canvas_refresh (emacs_env *env, emacs_value canvas)
+{
+  MODULE_FUNCTION_BEGIN ();
+#ifdef HAVE_CANVAS
+  canvas_refresh (value_to_lisp (canvas));
+#endif
+  MODULE_INTERNAL_CLEANUP ();
+}
+
 /* This function should return true if and only if maybe_quit would
    quit.  */
 static bool
@@ -1615,6 +1637,8 @@ initialize_environment (emacs_env *env, struct emacs_env_private *priv)
   env->open_channel = module_open_channel;
   env->make_interactive = module_make_interactive;
   env->make_unibyte_string = module_make_unibyte_string;
+  env->canvas_pixel = module_canvas_pixel;
+  env->canvas_refresh = module_canvas_refresh;
   return env;
 }
 
diff --git a/src/image.c b/src/image.c
index ccbf5db028f..6642317e6ea 100644
--- a/src/image.c
+++ b/src/image.c
@@ -1877,6 +1877,11 @@ prepare_image_for_display (struct frame *f, struct image *img)
       unblock_input ();
     }
 #endif
+
+  /* Copy canvas pixel into pixmap if refresh counter has been updated.  */
+  Lisp_Object canvas = img->lisp_data;
+  if (CANVASP (canvas) && XCANVAS (canvas)->refresh != img->refresh)
+    canvas_prepare (f, img);
 }
 
 
@@ -3356,8 +3361,10 @@ image_set_transform (struct frame *f, struct image *img)
 			      matrix[1][1], matrix[2][0], matrix[2][1]};
   cairo_pattern_t *pattern = cairo_pattern_create_rgb (0, 0, 0);
   cairo_pattern_set_matrix (pattern, &cr_matrix);
+  /* With the good filter we potentially get HW acceleration.
+     Performance degrades with CAIRO_FILTER_BEST.  */
   cairo_pattern_set_filter (pattern, smoothing
-                            ? CAIRO_FILTER_BEST : CAIRO_FILTER_NEAREST);
+                            ? CAIRO_FILTER_GOOD : CAIRO_FILTER_NEAREST);
   /* Dummy solid color pattern just to record pattern matrix.  */
   img->cr_data = pattern;
 # elif defined (HAVE_XRENDER)
@@ -5403,7 +5410,221 @@ xbm_load (struct frame *f, struct image *img)
   return success_p;
 }
 
+#ifdef HAVE_CANVAS
+
+/***********************************************************************
+			      Canvas
+ ***********************************************************************/
 
+/* Indices of image specification fields in canvas_format, below.  */
+
+enum canvas_keyword_index
+{
+  CANVAS_TYPE,
+  CANVAS_ID,
+  CANVAS_WIDTH,
+  CANVAS_HEIGHT,
+  CANVAS_ASCENT,
+  CANVAS_MARGIN,
+  CANVAS_RELIEF,
+  CANVAS_LAST
+};
+
+/* Vector of image_keyword structures describing the format
+   of valid user-defined image specifications.  */
+
+static const struct image_keyword canvas_format[CANVAS_LAST] =
+{
+  {":type",		IMAGE_SYMBOL_VALUE,			1},
+  {":canvas-id",	IMAGE_SYMBOL_VALUE,			1},
+  {":canvas-width",	IMAGE_POSITIVE_INTEGER_VALUE,		1},
+  {":canvas-height",	IMAGE_POSITIVE_INTEGER_VALUE,		1},
+  {":ascent",		IMAGE_ASCENT_VALUE,			0},
+  {":margin",		IMAGE_NON_NEGATIVE_INTEGER_VALUE_OR_PAIR, 0},
+  {":relief",		IMAGE_INTEGER_VALUE,			0},
+};
+
+/* Weak hash map associating the canvas id with the canvas object.  */
+
+static Lisp_Object canvas_map;
+
+/* Return true if OBJECT is a valid canvas image specification.  */
+
+static bool
+canvas_image_p (Lisp_Object object)
+{
+  struct image_keyword fmt[CANVAS_LAST];
+  memcpy (fmt, canvas_format, sizeof fmt);
+  return parse_image_spec (object, fmt, CANVAS_LAST, Qcanvas);
+}
+
+/* Get canvas object for IMAGE specification. Return nil on error.  */
+
+static Lisp_Object canvas_get (Lisp_Object image)
+{
+  struct image_keyword fmt[CANVAS_LAST];
+  memcpy (fmt, canvas_format, sizeof fmt);
+  if (!parse_image_spec (image, fmt, CANVAS_LAST, Qcanvas))
+    {
+      image_error ("Invalid canvas image specification");
+      return Qnil;
+    }
+
+  Lisp_Object id = fmt[CANVAS_ID].value,
+              canvas = Fgethash (id, canvas_map, Qnil);
+  int width = XFIXNAT (fmt[CANVAS_WIDTH].value),
+      height = XFIXNAT (fmt[CANVAS_HEIGHT].value);
+
+  if (!NILP (canvas))
+    {
+      struct Lisp_Canvas *c = XCANVAS (canvas);
+      if (c->width != width || c->height != height)
+        {
+	  image_error ("Inconsistent canvas dimension for :canvas-id %s",
+		       SSDATA (SYMBOL_NAME (id)));
+	  return Qnil;
+        }
+    }
+
+  if (NILP (canvas))
+    {
+      struct Lisp_Canvas *c =
+	  ALLOCATE_PSEUDOVECTOR (struct Lisp_Canvas, id, PVEC_CANVAS);
+      /* Use the string here since the symbol, since the symbol is used
+	 as key in the weak hash table `canvas_map'. */
+      c->id = SYMBOL_NAME (id);
+      c->refresh = 0;
+      c->width = width;
+      c->height = height;
+      c->pixel = xzalloc (4 * width * height);
+      canvas = make_lisp_ptr (c, Lisp_Vectorlike);
+      Fputhash (id, canvas, canvas_map);
+    }
+
+  return canvas;
+}
+
+/* Create canvas IMG in frame F.  Value is true if successful.  */
+
+static bool
+canvas_load (struct frame *f, struct image *img)
+{
+  Lisp_Object canvas = canvas_get (img->spec);
+
+  if (NILP (canvas))
+    return 0;
+
+  struct Lisp_Canvas *c = XCANVAS (canvas);
+  img->lisp_data = canvas;
+  img->width = c->width;
+  img->height = c->height;
+  img->background_valid = 1;
+  img->background_transparent_valid = 1;
+
+  Emacs_Pix_Container ximg;
+  if (!image_create_x_image_and_pixmap (f, img, c->width, c->height, 0, &ximg, 0))
+    return 0;
+
+  image_put_x_image (f, img, ximg, 0);
+
+  return 1;
+}
+
+/* Prepare image IMG from canvas for display.  */
+
+void
+canvas_prepare (struct frame *f, struct image *img)
+{
+  block_input ();
+
+  struct Lisp_Canvas *canvas = XCANVAS (img->lisp_data);
+  img->refresh = canvas->refresh;
+  uint32_t* src = canvas->pixel;
+  int width = canvas->width, height = canvas->height;
+
+  /* Alpha channel is preserved here. Potentially preserve it when
+     drawing the image in x_draw_image_glyph_string?  */
+#ifdef USE_CAIRO
+  cairo_surface_t* surface;
+  if (img->cr_data
+      && cairo_pattern_get_type (img->cr_data) == CAIRO_PATTERN_TYPE_SURFACE
+      && !cairo_pattern_get_surface (img->cr_data, &surface))
+    {
+      cairo_surface_flush (surface);
+      int stride = cairo_image_surface_get_stride (surface);
+      unsigned char *dst = cairo_image_surface_get_data (surface);
+      if (stride == 4 * width) /* Fast path */
+	{
+	  memcpy (dst, src, stride * height);
+	}
+      else
+	{
+	  for (int y = 0; y < height; ++y)
+	    memcpy (dst + (y * stride), src + (y * width), 4 * width);
+	}
+      cairo_surface_mark_dirty (surface);
+    }
+#elif defined HAVE_X_WINDOWS
+  int depth = FRAME_DISPLAY_INFO (f)->n_planes;
+  XImage *ximg = XCreateImage (FRAME_X_DISPLAY (f), FRAME_X_VISUAL (f),
+			       depth, ZPixmap, 0, NULL, width, height,
+			       depth > 16 ? 32 : depth > 8 ? 16 : 8, 0);
+  if (ximg)
+    {
+      ximg->data = xmalloc (ximg->bytes_per_line * height);
+      for (int y = 0; y < height; ++y)
+	{
+	  for (int x = 0; x < width; ++x)
+	    {
+	      uint32_t c = src[y * width + x],
+		       r = (c >> 16) & 255,
+		       g = (c >>  8) & 255,
+		       b = c         & 255;
+	      PUT_PIXEL (ximg, x, y, lookup_rgb_color (f, r << 8, g << 8, b << 8));
+	    }
+	}
+      gui_put_x_image (f, ximg, img->pixmap, width, height);
+      x_destroy_x_image (ximg);
+    }
+#else
+# error Canvas not supported by the platform
+#endif
+
+  unblock_input ();
+}
+
+/* Access canvas buffer. */
+
+uint32_t* canvas_pixel (Lisp_Object image)
+{
+  Lisp_Object canvas = canvas_get (image);
+
+  if (NILP (canvas))
+    error ("Not a canvas");
+
+  return XCANVAS (canvas)->pixel;
+}
+
+/* Refresh canvas IMAGE.  */
+
+void canvas_refresh (Lisp_Object image)
+{
+  Lisp_Object canvas = canvas_get (image);
+
+  if (NILP (canvas))
+    error ("Not a canvas");
+
+  /* Increment canvas refresh counter.  */
+  int *p = &XCANVAS (canvas)->refresh, n = *p + 1;
+  *p = n ? n : 1;
+
+  /* Redraw all glyphs.  */
+  block_input ();
+  redraw_canvas_glyphs (canvas);
+  unblock_input ();
+}
+
+#endif
 
 /***********************************************************************
 			      XPM images
@@ -12958,6 +13179,9 @@ initialize_image_type (struct image_type const *type)
 #if defined HAVE_WEBP
  { SYMBOL_INDEX (Qwebp), webp_image_p, webp_load, image_clear_image,
    IMAGE_TYPE_INIT (init_webp_functions) },
+#endif
+#if defined HAVE_CANVAS
+  { SYMBOL_INDEX (Qcanvas), canvas_image_p, canvas_load, image_clear_image },
 #endif
  { SYMBOL_INDEX (Qxbm), xbm_image_p, xbm_load, image_clear_image },
  { SYMBOL_INDEX (Qpbm), pbm_image_p, pbm_load, image_clear_image },
@@ -13160,6 +13384,13 @@ syms_of_image (void)
 #endif /* NS_IMPL_GNUSTEP && !HAVE_WEBP */
 #endif
 
+#if defined (HAVE_CANVAS)
+  DEFSYM (Qcanvas, "canvas");
+  add_image_type (Qcanvas);
+  canvas_map = make_hash_table (&hashtest_eq, DEFAULT_HASH_SIZE, Weak_Key_Or_Value);
+  staticpro (&canvas_map);
+#endif
+
 #if defined (HAVE_IMAGEMAGICK)
   DEFSYM (Qimagemagick, "imagemagick");
   add_image_type (Qimagemagick);
diff --git a/src/lisp.h b/src/lisp.h
index 6d2fd4b83f2..b2161798fad 100644
--- a/src/lisp.h
+++ b/src/lisp.h
@@ -1010,6 +1010,7 @@ DEFINE_GDB_SYMBOL_END (PSEUDOVECTOR_FLAG)
   PVEC_TS_NODE,
   PVEC_TS_COMPILED_QUERY,
   PVEC_SQLITE,
+  PVEC_CANVAS,
 
   /* These should be last, for internal_equal and sxhash_obj.  */
   PVEC_CLOSURE,
@@ -2911,6 +2912,19 @@ xmint_pointer (Lisp_Object a)
   return XUNTAG (a, Lisp_Vectorlike, struct Lisp_Misc_Ptr)->pointer;
 }
 
+struct Lisp_Canvas
+{
+  union vectorlike_header header;
+  /* Canvas ID as string.  */
+  Lisp_Object id;
+  /* Incremented if the canvas should be redrawn.  */
+  int refresh;
+  /* Dimension of the canvas.  */
+  int width, height;
+  /* Pinned pixel memory buffer in ARGB32 format.  */
+  uint32_t *pixel;
+} GCALIGNED_STRUCT;
+
 struct Lisp_Sqlite
 {
   union vectorlike_header header;
@@ -3024,6 +3038,19 @@ XSQLITE (Lisp_Object a)
   return XUNTAG (a, Lisp_Vectorlike, struct Lisp_Sqlite);
 }
 
+INLINE bool
+CANVASP (Lisp_Object x)
+{
+  return PSEUDOVECTORP (x, PVEC_CANVAS);
+}
+
+INLINE struct Lisp_Canvas *
+XCANVAS (Lisp_Object a)
+{
+  eassert (CANVASP (a));
+  return XUNTAG (a, Lisp_Vectorlike, struct Lisp_Canvas);
+}
+
 INLINE bool
 BIGNUMP (Lisp_Object x)
 {
diff --git a/src/module-env-31.h b/src/module-env-31.h
index e9827b18382..6f7af1ec59c 100644
--- a/src/module-env-31.h
+++ b/src/module-env-31.h
@@ -1,3 +1,14 @@
   /* Add module environment functions newly added in Emacs 31 here.
      Before Emacs 31 is released, remove this comment and start
      module-env-32.h on the master branch.  */
+
+  /* Get pointer to the pixel buffer of CANVAS.  The buffer is in row
+     major order and has the size width * height.  The pixel format is
+     ARGB32.  The pointer will be valid as long as CANVAS is alive.
+     Return NULL in case error.   */
+  uint32_t* (*canvas_pixel) (emacs_env *env, emacs_value canvas)
+    EMACS_ATTRIBUTE_NONNULL(1);
+
+  /* Redraw the CANVAS.  */
+  void (*canvas_refresh) (emacs_env *env, emacs_value canvas)
+    EMACS_ATTRIBUTE_NONNULL(1);
diff --git a/src/pdumper.c b/src/pdumper.c
index c21af24d9f1..d6f87d30b58 100644
--- a/src/pdumper.c
+++ b/src/pdumper.c
@@ -3071,6 +3071,7 @@ dump_vectorlike (struct dump_context *ctx,
     case PVEC_FREE:
     case PVEC_TS_PARSER:
     case PVEC_TS_NODE:
+    case PVEC_CANVAS:
       break;
     }
   int iptype = ptype;
diff --git a/src/print.c b/src/print.c
index 17e271967cb..2a803b48ab6 100644
--- a/src/print.c
+++ b/src/print.c
@@ -2133,6 +2133,15 @@ print_vectorlike_unreadable (Lisp_Object obj, Lisp_Object printcharfun,
 	return;
       }
 
+    case PVEC_CANVAS:
+      {
+	struct Lisp_Canvas *c = XCANVAS (obj);
+	int i = sprintf (buf, "#<canvas id=%s width=%d height=%d refresh=%d pixel=%p>",
+			 SSDATA (c->id), c->width, c->height, c->refresh, c->pixel);
+	strout (buf, i, i, printcharfun);
+	return;
+      }
+
     /* Types handled earlier.  */
     case PVEC_NORMAL_VECTOR:
     case PVEC_RECORD:
diff --git a/src/window.c b/src/window.c
index c4f2e4e491f..f609ac6bf9b 100644
--- a/src/window.c
+++ b/src/window.c
@@ -3151,10 +3151,11 @@ mru_rooted_frame (struct frame *f)
 enum window_loop
 {
   WINDOW_LOOP_UNUSED,
-  GET_BUFFER_WINDOW,		    /* Arg is buffer */
-  REPLACE_BUFFER_IN_WINDOWS_SAFELY, /* Arg is buffer */
-  REDISPLAY_BUFFER_WINDOWS,	    /* Arg is buffer */
-  CHECK_ALL_WINDOWS                 /* Arg is ignored */
+  GET_BUFFER_WINDOW,                     /* Arg is buffer */
+  REPLACE_BUFFER_IN_WINDOWS_SAFELY,      /* Arg is buffer */
+  REDISPLAY_BUFFER_WINDOWS_NO_MODE_LINE, /* Arg is buffer */
+  REDISPLAY_BUFFER_WINDOWS_MODE_LINE,    /* Arg is buffer */
+  CHECK_ALL_WINDOWS                      /* Arg is ignored */
 };
 
 static Lisp_Object
@@ -3258,13 +3259,17 @@ window_loop (enum window_loop type, Lisp_Object obj, bool mini,
 	      }
 	    break;
 
-	  case REDISPLAY_BUFFER_WINDOWS:
+	  case REDISPLAY_BUFFER_WINDOWS_MODE_LINE:
+	  case REDISPLAY_BUFFER_WINDOWS_NO_MODE_LINE:
 	    if (EQ (w->contents, obj))
 	      {
+		if (type == REDISPLAY_BUFFER_WINDOWS_MODE_LINE)
+		  {
+		    w->update_mode_line = true;
+		    update_mode_lines = 27;
+		  }
 		mark_window_display_accurate (window, false);
-		w->update_mode_line = true;
 		XBUFFER (obj)->prevent_redisplay_optimizations_p = true;
-		update_mode_lines = 27;
 		best_window = window;
 	      }
 	    break;
@@ -4486,17 +4491,19 @@ display_buffer (Lisp_Object buffer, Lisp_Object not_this_window_p, Lisp_Object o
 }
 
 DEFUN ("force-window-update", Fforce_window_update, Sforce_window_update,
-       0, 1, 0,
+       0, 2, 0,
        doc: /* Force all windows to be updated on next redisplay.
 If optional arg OBJECT is a window, force redisplay of that window only.
 If OBJECT is a buffer or buffer name, force redisplay of all windows
-displaying that buffer.  */)
-  (Lisp_Object object)
+displaying that buffer.  Do not update mode lines if NO-MODE-LINE is
+non-nil. */)
+  (Lisp_Object object, Lisp_Object no_mode_line)
 {
   if (NILP (object))
     {
       windows_or_buffers_changed = 29;
-      update_mode_lines = 28;
+      if (!NILP (no_mode_line))
+        update_mode_lines = 28;
       return Qt;
     }
 
@@ -4504,10 +4511,13 @@ DEFUN ("force-window-update", Fforce_window_update, Sforce_window_update,
     {
       struct window *w = XWINDOW (object);
       mark_window_display_accurate (object, false);
-      w->update_mode_line = true;
       if (BUFFERP (w->contents))
 	XBUFFER (w->contents)->prevent_redisplay_optimizations_p = true;
-      update_mode_lines = 29;
+      if (!NILP (no_mode_line))
+        {
+	  w->update_mode_line = true;
+	  update_mode_lines = 29;
+	}
       return Qt;
     }
 
@@ -4518,7 +4528,10 @@ DEFUN ("force-window-update", Fforce_window_update, Sforce_window_update,
     {
       /* If buffer is live and shown in at least one window, find
 	 all windows showing this buffer and force update of them.  */
-      object = window_loop (REDISPLAY_BUFFER_WINDOWS, object, false, Qvisible);
+      object = window_loop ((NILP (no_mode_line)
+			     ? REDISPLAY_BUFFER_WINDOWS_MODE_LINE
+			     : REDISPLAY_BUFFER_WINDOWS_NO_MODE_LINE),
+			    object, false, Qvisible);
       return NILP (object) ? Qnil : Qt;
     }
 
diff --git a/src/xdisp.c b/src/xdisp.c
index 22e178fcdc9..14a87323191 100644
--- a/src/xdisp.c
+++ b/src/xdisp.c
@@ -18241,7 +18241,11 @@ mark_window_display_accurate_1 (struct window *w, bool accurate_p)
       w->preserve_vscroll_p = false;
     }
 
-  w->redisplay = !accurate_p;
+  /* Ensure that `redisplay_other_windows' is called.  */
+  if (accurate_p)
+    w->redisplay = false;
+  else
+    wset_redisplay (w);
 }
 
 
@@ -32475,6 +32479,56 @@ append_stretch_glyph (struct it *it, Lisp_Object object,
     IT_EXPAND_MATRIX_WIDTH (it, area);
 }
 
+static void redraw_canvas_glyphs_window_1 (struct window *w, Lisp_Object canvas)
+{
+  if (!w->current_matrix)
+    return;
+
+  struct frame* f = WINDOW_XFRAME (w);
+
+  for (int y = 0; y < w->current_matrix->nrows; ++y)
+    {
+      struct glyph_row *row = w->current_matrix->rows + y;
+      if (row->enabled_p)
+	  {
+	  int start = row->x;
+	  for (int x = 0; x < row->used[TEXT_AREA]; ++x)
+	    {
+	      struct glyph *glyph = row->glyphs[TEXT_AREA] + x;
+	      if (glyph->type == IMAGE_GLYPH)
+		{
+		  struct image* img = IMAGE_OPT_FROM_ID (f, glyph->u.img_id);
+		  if (img && EQ (img->lisp_data, canvas))
+		    {
+		      canvas_prepare (f, img);
+		      draw_glyphs (w, start, row, TEXT_AREA, x, x + 1, DRAW_NORMAL_TEXT, 0);
+		    }
+		}
+	      start += glyph->pixel_width;
+	    }
+	}
+    }
+}
+
+static void redraw_canvas_glyphs_window (struct window *w, Lisp_Object canvas)
+{
+  while (w)
+    {
+      if (WINDOWP (w->contents))
+	redraw_canvas_glyphs_window (XWINDOW (w->contents), canvas);
+      else
+	redraw_canvas_glyphs_window_1 (w, canvas);
+      w = NILP (w->next) ? NULL : XWINDOW (w->next);
+    }
+}
+
+void redraw_canvas_glyphs (Lisp_Object canvas)
+{
+  Lisp_Object tail, frame;
+  FOR_EACH_FRAME (tail, frame)
+    redraw_canvas_glyphs_window (XWINDOW (XFRAME (frame)->root_window), canvas);
+}
+
 #endif	/* HAVE_WINDOW_SYSTEM */
 
 /* Produce a stretch glyph for iterator IT.  IT->object is the value
diff --git a/test/src/emacs-module-resources/mod-test.c b/test/src/emacs-module-resources/mod-test.c
index 7e68d32883e..0c31d572ea0 100644
--- a/test/src/emacs-module-resources/mod-test.c
+++ b/test/src/emacs-module-resources/mod-test.c
@@ -740,6 +740,28 @@ Fmod_test_make_string (emacs_env *env, ptrdiff_t nargs,
   return ret;
 }
 
+static emacs_value
+Fmod_test_canvas (emacs_env *env, ptrdiff_t nargs,
+		  emacs_value *args, void *data)
+{
+  assert (nargs == 2);
+
+  if (env->is_not_nil (env, args[1]))
+    {
+      uint32_t* buf = env->canvas_pixel (env, args[0]);
+      if (!buf)
+        return env->intern (env, "nil");
+      assert (buf);
+      memset (buf, 42, 4 * 800 * 600);
+      env->canvas_refresh (env, args[0]);
+    }
+  else
+    {
+      assert (!env->canvas_pixel (env, args[0]));
+    }
+  return env->intern (env, "t");
+}
+
 /* Lisp utilities for easier readability (simple wrappers).  */
 
 /* Provide FEATURE to Emacs.  */
@@ -841,6 +863,7 @@ #define DEFUN(lsym, csym, amin, amax, doc, data) \
   DEFUN ("mod-test-funcall", Fmod_test_funcall, 1, emacs_variadic_function,
          NULL, NULL);
   DEFUN ("mod-test-make-string", Fmod_test_make_string, 2, 2, NULL, NULL);
+  DEFUN ("mod-test-canvas", Fmod_test_canvas, 2, 2, NULL, NULL);
 
 #undef DEFUN
 
diff --git a/test/src/emacs-module-tests.el b/test/src/emacs-module-tests.el
index 769153a41fe..edf9b44e62f 100644
--- a/test/src/emacs-module-tests.el
+++ b/test/src/emacs-module-tests.el
@@ -579,4 +579,28 @@ mod-test-make-string/nonempty
         (should (string-equal first second))
         (should-not (eq first second))))))
 
+;;; Canvas tests
+
+(ert-deftest mod-test-canvas/valid ()
+  (skip-unless (image-type-available-p 'canvas))
+  (skip-unless (display-graphic-p))
+  (should (mod-test-canvas '(image :type canvas
+                                   :canvas-id mod-test
+                                   :canvas-width 800
+                                   :canvas-height 600)
+                           t)))
+
+(ert-deftest mod-test-canvas/invalid ()
+  (skip-unless (image-type-available-p 'canvas))
+  (skip-unless (display-graphic-p))
+  (should-error (mod-test-canvas '(image :type canvas
+                                         :canvas-width 800
+                                         :canvas-height 600)
+                                 t))
+  (should-error (mod-test-canvas '(image :type canvas
+                                         :canvas-id mod-test)
+                                 t))
+  (should-error (mod-test-canvas nil nil))
+  (should-error (mod-test-canvas '(image :type xbm :data "") nil)))
+
 ;;; emacs-module-tests.el ends here
-- 
2.47.3

